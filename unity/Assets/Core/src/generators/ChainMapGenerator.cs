using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Numerics;

namespace terrainGenerator.Generator {

	/*
		 Generates a map step-by-step.
		 This variant takes a list of steps and executes them in order, allowing for greater flexibility when generating a map.
		 This way, any number of steps can be executed in any order, allowing the user to repeat previous steps or alter the order.
		 It ensures that all map aspects are added before they're needed.
	*/
	public class ChainMapGenerator : IMapGenerator {

		/*
			The index of the next step to perform.
		*/
		public int NextIndex { get; private set; } = 0;

		/*
			The total number of steps to perform.
		*/
		public int StepCount => _steps.Count;

		/*
			Whether or not the generator has finished.
		*/
		public bool Finished => NextIndex >= StepCount;

		/*
			Gets the last generator performed.
		*/
		public IStepGenerator LastGen => (NextIndex == 0) ? null : _steps[NextIndex - 1];

		/*
			The state of the generator.
		*/
		public GeneratorState State { get; }

		/*
			The grid of the map being generated.
		*/
		public Grid Grid { get; protected set; } //grid object


		/*
			The steps of the generation process.
		*/
		private List<IStepGenerator> _steps;


		/*
			Make a ChainMapGenerator. 
		*/
		public ChainMapGenerator(List<IStepGenerator> steps, GenParams par, GameMap basis = null) {
			if(steps == null) throw new ArgumentNullException(nameof(steps));
			if(steps.Count == 0) throw new ArgumentException(nameof(steps), "Steps can't be empty.");

			_steps = steps;

			if(basis != null) {
				// Create new state.
				State = GeneratorState.Create(par, basis.State);
				// Pass over the grid.
				Grid = basis.Grid;

			} else {
				// Create new state.
				State = GeneratorState.Create(par);
				// Create a new, empty grid.
				var emptyBiome = State.GetDefaultBiome(BiomeType.Empty);
				Grid = new Grid(State.Width, State.Height, emptyBiome);
			}

			// Go through and check that all required aspects are added beforehand (Or in the basis map).
			_isValidSequence(_steps, State.MapAspects);

			SetUp();
		}

		/*
			Sets up the things that are initially required to begin messing with stuff. 
		*/
		private void SetUp() {
			// Seed the steps.
			var rng = new Random(State.Seed);

			foreach(var gen in _steps) {
				gen.SetSeed(rng.Next(0, int.MaxValue));
			}
		}


		/*
			Runs through and ensures that all required map aspects are added before they're used.
		*/
		private static bool _isValidSequence(List<IStepGenerator> steps, MapAspects aspects = MapAspects.None) {
			foreach(var gen in steps) {
				var missing = ~aspects & gen.RequiredMapAspects;
				if(missing != MapAspects.None)
					throw new ArgumentException(nameof(steps), $"Step \"{gen.GetType()}\" is missing the following required map aspects: [{missing}]");
				aspects |= gen.AddedMapAspects;
			}
			return true;
		}

		/*
			Handles using a generator on the map.
		*/
		private bool _useGenerator(IStepGenerator generator) {
			Grid = generator.Use(Grid, State);
			return true;
		}



		/*
			Runs through the next step in the process.
			If already finished, throws an exception.
		*/
		public ChainMapGenerator Next() {
			if(Finished) throw new InvalidOperationException("All steps have already been ran.");

			var gen = _steps[NextIndex];
			_useGenerator(gen);

			NextIndex++;
			return this;
		}

		/*
			Runs through all remaining steps and returns the resulting map.
			Takes an optional callback function that will be called after each successful step if defined.
		*/
		public GameMap Generate(Action<Grid, IGeneratorState, IStepGenerator, int> callback = null) {
			while(NextIndex < StepCount) {
				var gen = _steps[NextIndex];
				_useGenerator(gen);

				if(callback != null) callback(Grid, State, gen, NextIndex);

				NextIndex++;
			}

			return GetMap();
		}

		/*
			Get the map generated by this generator.
		*/
		public GameMap GetMap() {
			if(!MapIsValid()) throw new InvalidOperationException("The map generated so far is not currently valid for return.");
			return GameMap.Create(Grid, State);
		}


		/*
			Check if the current result is a valid map.
		*/
		public bool MapIsValid() {
			// Check that all biomes are in the dict.
			var biomes = State.Biomes;
			for(int i = 0; i < Grid.Length; ++i) {
				var t = Grid[i];
				var b = t.Biome;
				if(b != biomes[b.Id]) {
					return false;
				}
			}

			return true;
		}


		GameMap IMapGenerator.Generate() => Generate(null);

		IGeneratorState IMapGenerator.State => State;
		IGrid IMapGenerator.Grid => Grid;
	}
}